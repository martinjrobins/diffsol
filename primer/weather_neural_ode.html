<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Example: Weather prediction using neural ODEs - Diffsol</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>
        <script defer data-domain="martinjrobins.github.io/diffsol" src="https://plausible-oxrse.fly.dev/js/script.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Diffsol</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="example-weather-prediction-using-neural-odes"><a class="header" href="#example-weather-prediction-using-neural-odes">Example: Weather prediction using Neural ODEs</a></h1>
<p>If we wish to train a neural network to predict the weather or any other time series dataset, we can use a Neural ODE. A Neural ODE replaces the rhs of an ODE with a neural network.</p>
<p>$$
\frac{dy}{dt} = f(y, p)
$$</p>
<p>Here, \(y(t)\) is the state of the system at time \(t\), and \(f\) is a neural network with parameters \(p\). The neural network is trained to predict the derivative of the state, and the ODE solver is used to integrate the state forward in time, and to calculate gradients of the loss function with respect to the parameters of the neural network.</p>
<p>In this example, we will duplicate the weather prediction example from the excellent <a href="https://sebastiancallh.github.io/post/neural-ode-weather-forecast/">blog post</a> by Sebastian Callh, but instead using Diffsol as the solver. We'll skip over some of the details, but you can read more details about the problem setup in the original blog post, and see the full code in the <a href="https://github.com/martinjrobins/diffsol">Diffsol repository</a>.</p>
<p>First we'll need a neural network model, and we'll use <a href="https://github.com/patrick-kidger/equinox">Equinox</a> and <a href="https://docs.jax.dev/en/latest/index.html">JAX</a> for this. We'll define a simple neural network with 3 layers like so</p>
<pre><code class="language-python">class NeuralNetwork(eqx.Module):
    layers: list

    def __init__(self, data_dim, key):
        key1, key2, key3 = jax.random.split(key, 3)
        self.layers = [
            eqx.nn.Linear(data_dim, 64, key=key1),
            eqx.nn.Linear(64, 32, key=key2),
            eqx.nn.Linear(32, data_dim, key=key3),
        ]

    def __call__(self, x):
        x = jax.nn.silu(self.layers[0](x))  # Swish = SiLU
        x = jax.nn.silu(self.layers[1](x))
        x = self.layers[2](x)
        return x
</code></pre>
<p>We will then create four JAX functions that will allow us to calculate:</p>
<ul>
<li>the rhs function \(f(y, p)\) of the Neural ODE, where \(y\) is the state of the system and \(p\) are the parameters.</li>
<li>the Jacobian-vector product of the rhs function with respect to the state \(y\).</li>
<li>the negative vector-Jacobian product of the rhs function with respect to the state \(y\).</li>
<li>the negative vector-Jacobian product of the rhs function with respect to the parameters \(p\).</li>
</ul>
<p>We will need all four of these to define the ODE problem and to solve it using Diffsol.</p>
<pre><code class="language-python">key = jax.random.PRNGKey(0)
model = NeuralNetwork(data_dim=data_dim, key=key)
y = jnp.zeros((data_dim,))
v = jnp.zeros((data_dim,))
params, static = eqx.partition(model, eqx.is_array)
p, unravel_params = ravel_pytree(params)


def rhs(p, y):
    params = unravel_params(p)
    model = eqx.combine(params, static)
    return model(y)


def rhs_jac_mul(p, y, v):
    return jax.jvp(ft.partial(rhs, p), (y,), (v,))[1]


def rhs_jac_transpose_mul(p, y, v):
    return -jax.vjp(ft.partial(rhs, p), y)[1](v)[0]


def rhs_sens_transpose_mul(p, y, v):
    return -jax.vjp(ft.partial(rhs, y=y), p)[1](v)[0]
</code></pre>
<p>Finally, we can export all four of these JAX functions to ONNX, which will allow us to use them within rust.</p>
<pre><code class="language-python">def to_onnx(model, inputs, filename):
    sig = [tf.TensorSpec(inpt[0].shape, inpt[0].dtype, name=inpt[1]) for inpt in inputs]
    inference_tf = jax2tf.convert(model, enable_xla=False)
    inference_tf = tf.function(inference_tf, autograph=False)
    inference_onnx = tf2onnx.convert.from_function(inference_tf, input_signature=sig)
    model_proto, _external_tensor_storage = inference_onnx
    with open(filename, "wb") as f:
        f.write(model_proto.SerializeToString())
    return model_proto
</code></pre>
<p>Within rust now, we can define a Diffsol system of equations by creating a struct <code>NeuralOde</code>. We'll use the <a href="https://ort.pyke.io/"><code>ort</code></a> crate and the ONNX Runtime to load the ONNX models that we made in Python.</p>
<pre><code class="language-rust ignore">struct NeuralOde {
    rhs: Session,
    rhs_jac_mul: Session,
    rhs_jac_transpose_mul: Session,
    rhs_sens_transpose_mul: Session,
    input_y: RefCell&lt;Array1&lt;f32&gt;&gt;,
    input_v: RefCell&lt;Array1&lt;f32&gt;&gt;,
    input_p: Array1&lt;f32&gt;,
    y0: V,
}

impl NeuralOde {
    fn new_session(filename: &amp;str) -&gt; Result&lt;Session&gt; {
        let full_filename = format!("{}{}", BASE_MODEL_DIR, filename);
        let session = Session::builder()?
            .with_optimization_level(GraphOptimizationLevel::Level3)?
            .with_intra_threads(4)?
            .commit_from_file(full_filename.as_str())?;
        Ok(session)
    }
    fn new(y0: V) -&gt; Result&lt;Self&gt; {
        let rhs = Self::new_session("rhs.onnx")?;
        let rhs_jac_mul = Self::new_session("rhs_jac_mul.onnx")?;
        let rhs_jac_transpose_mul = Self::new_session("rhs_jac_transpose_mul.onnx")?;
        let rhs_sens_transpose_mul = Self::new_session("rhs_sens_transpose_mul.onnx")?;
        let mut nparams = 0;
        for input in rhs.inputs.iter() {
            if input.name == "p" {
                nparams = input.input_type.tensor_dimensions().unwrap()[0] as usize;
                break;
            }
        }
        let mut rng = rand::rng();
        let elem = Uniform::&lt;f32&gt;::new(0.0, 1.0).unwrap();
        let params = Array1::from_shape_fn((nparams,), |_| elem.sample(&amp;mut rng));
        let y0_ndarray = Array1::from_shape_fn((y0.len(),), |i| y0[i] as f32);

        Ok(Self {
            y0,
            rhs,
            rhs_jac_mul,
            rhs_jac_transpose_mul,
            rhs_sens_transpose_mul,
            input_p: params,
            input_v: RefCell::new(y0_ndarray.clone()),
            input_y: RefCell::new(y0_ndarray),
        })
    }

    fn data_dim(&amp;self) -&gt; usize {
        self.y0.len()
    }
}</code></pre>
<p>We'll also implement the <code>OdeSystemAdjoint</code> trait for <code>NeuralOde</code>, which will allow us to use the adjoint method to calculate gradients of out loss function with respect to the parameters of the neural network. As an example, here is the implementation of the <code>NonLinearOp</code> trait:</p>
<pre><code class="language-rust ignore">impl NonLinearOp for Rhs&lt;'_&gt; {
    fn call_inplace(&amp;self, x: &amp;Self::V, _t: Self::T, y: &amp;mut Self::V) {
        let mut y_input = self.0.input_y.borrow_mut();
        y_input
            .iter_mut()
            .zip(x.inner().iter())
            .for_each(|(y, x)| *y = *x as f32);
        let outputs = self
            .0
            .rhs
            .run(
                inputs![
                    "p" =&gt; self.0.input_p.view(),
                    "y" =&gt; y_input.view(),
                ]
                .unwrap(),
            )
            .unwrap();
        let y_data = outputs["Identity_1:0"].try_extract_tensor::&lt;f32&gt;().unwrap();
        y.inner_mut()
            .iter_mut()
            .zip(y_data.as_slice().unwrap())
            .for_each(|(y, x)| *y = *x as f64);
    }
}</code></pre>
<p>We'll also need an optimiser, so we'll write an AdamW algorithm using the definition in the <a href="https://pytorch.org/docs/stable/generated/torch.optim.AdamW.html">PyTorch documentation</a> as a guide:</p>
<pre><code class="language-rust ignore">struct AdamW {
    lr: T,
    betas: (T, T),
    eps: T,
    m: V,
    m_hat: V,
    v: V,
    v_hat: V,
    grads2: V,
    lambda: T,
    t: i32,
}

impl AdamW {
    fn new(nparams: usize, ctx: C) -&gt; Self {
        let lr = 1e-2;
        let betas = (0.9, 0.999);
        let eps = 1e-8;
        let m = V::zeros(nparams, ctx.clone());
        let m_hat = V::zeros(nparams, ctx.clone());
        let v = V::zeros(nparams, ctx.clone());
        let v_hat = V::zeros(nparams, ctx.clone());
        let grads2 = V::zeros(nparams, ctx.clone());
        let lambda = 1e-2;
        Self {
            lr,
            betas,
            eps,
            m,
            m_hat,
            v,
            v_hat,
            lambda,
            grads2,
            t: 0,
        }
    }

    fn step(&amp;mut self, params: &amp;mut V, grads: &amp;V) {
        self.t += 1;
        params.mul_assign(Scale(1.0 - self.lr * self.lambda));
        self.m.axpy(1.0 - self.betas.0, grads, self.betas.0);
        self.grads2.copy_from(grads);
        self.grads2.component_mul_assign(grads);
        self.v.axpy(1.0 - self.betas.1, &amp;self.grads2, self.betas.1);
        self.m_hat = &amp;self.m * Scale(1.0 / (1.0 - self.betas.0.powi(self.t)));
        self.v_hat = &amp;self.v * Scale(1.0 / (1.0 - self.betas.1.powi(self.t)));
        params
            .inner_mut()
            .iter_mut()
            .zip(self.v_hat.inner().iter())
            .zip(self.m_hat.inner().iter())
            .for_each(|((params_i, v_hat_i), m_hat_i)| {
                *params_i -= self.lr * m_hat_i / (v_hat_i.sqrt() + self.eps)
            });
    }
}</code></pre>
<p>We'll then define our loss function, which will return the sum of squared errors between the solution and the data points, along with the gradients of the loss function with respect to the parameters. Since the size of the parameter vector is quite large (&gt;2000), we'll use the adjoint method to calculate the gradients.</p>
<pre><code class="language-rust ignore">fn loss_fn(
    problem: &amp;mut OdeSolverProblem&lt;NeuralOde&gt;,
    p: &amp;V,
    ts_data: &amp;[T],
    ys_data: &amp;M,
    g_m: &amp;mut M,
) -&gt; Result&lt;(T, V), DiffsolError&gt; {
    problem.eqn.set_params(p);
    let (c, ys) = problem
        .bdf::&lt;LS&gt;()?
        .solve_dense_with_checkpointing(ts_data, None)?;
    let mut loss = 0.0;
    for j in 0..g_m.ncols() {
        let delta = ys.column(j) - ys_data.column(j);
        loss += delta.inner().dot(delta.inner());
        let g_m_i = delta * Scale(2.0);
        g_m.column_mut(j).copy_from(&amp;g_m_i);
    }
    let adjoint_solver = problem.bdf_solver_adjoint::&lt;LS, _&gt;(c, Some(1)).unwrap();
    let soln = adjoint_solver.solve_adjoint_backwards_pass(ts_data, &amp;[g_m])?;
    Ok((loss, soln.into_common().sg.pop().unwrap()))
}</code></pre>
<p>Finally, we can train the neural network to predict the weather. Following the example given in the linked blog post above, we'll train in stages by increasing the number of datapoints by four each time. Each time we'll train for 150 steps using the AdamW optimiser.</p>
<pre><code class="language-rust ignore">fn train_one_round(
    problem: &amp;mut OdeSolverProblem&lt;NeuralOde&gt;,
    ts_data: &amp;[T],
    ys_data: &amp;M,
    p: &amp;mut V,
) {
    let mut gm = M::zeros(problem.eqn.nout(), ts_data.len(), problem.context().clone());
    let mut adam = AdamW::new(problem.eqn.nparams(), problem.context().clone());
    for _ in 0..150 {
        match loss_fn(problem, p, ts_data, ys_data, &amp;mut gm) {
            Ok((loss, g)) =&gt; {
                println!("loss: {}", loss);
                adam.step(p, &amp;g)
            }
            Err(e) =&gt; {
                panic!("{}", e);
            }
        };
    }
}</code></pre>
<p>To give an indication of the results, we'll plot the results after we've used the first 20 data-points to train the model, and we'll predict the model solution to the entire dataset.</p>
<div id="neural-ode-weather-prediction" class="plotly-graph-div" style="height:100%; width:100%;"></div>
<script type="text/javascript">
    Plotly.newPlot("neural-ode-weather-prediction", {"data":[{"type":"scatter","name":"mean_temp_data","mode":"markers","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[-1.8746853167178659,-1.191136175338744,-0.34302325286684865,0.5242379785018397,1.2204600070685376,1.0356392870547464,0.7764584747154226,0.6173196324731776,0.6590820769246282,0.1297597571839188,-0.9138613708403621,-1.43191062565957,-1.6811401485200248,-1.350977634598048,-0.517147085210099,0.40489534845729463,0.8822735363935678,1.3622341157160343,0.9719293885451523,0.8831917343164234,0.6479441105980918,0.18215245283677287,-0.7295302919504851,-1.4826273684721798,-1.784298879716084,-0.9167497553279891,-0.5236372947384939,0.3970002961069298,1.1599559187477058,1.0722395046531752,0.740228317727797,0.7289936828795937,0.7745196273120032,0.234731365471876,-0.6368270966107191,-1.4589668577863832,-1.4376121514984388,-0.8833449276118914,0.06870249488640581,1.0455023341197416,1.3562287140913167,1.3873356804220447,0.8067242113010039,0.8410630606549492,0.8928614257188988,0.5337309523464745,-0.32260436328875725,-1.0763261134169495,-1.381555913431708,-0.9797127576870259,-0.20902418198438702,0.7893040760475085]},{"type":"scatter","name":"mean_temp_predict","mode":"lines","x":[20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[0.5060383828209065,0.04193911626713242,-0.7254366254067464,-1.3883146554051666,-1.4869132109102785,-1.0726413892822,-0.40489765955201756,0.318529041633813,0.9680258979043675,1.0645743295024983,0.7630761213855735,0.5902499330719362,0.3205967780516363,-0.24153137372216754,-0.9723819683233675,-1.3863766018528885,-1.240619741688715,-0.7084762970892232,-0.02427274050617308,0.6598567441575677,1.0806699147398666,0.8593658100477722,0.6322403740336222,0.43076839409923745,0.0064382482304854265,-0.6715695517694305,-1.2356740486477213,-1.2922936866754282,-0.8859842384153864,-0.2501026354634277,0.4328517510612345,0.9905036810103283],"line":{"dash":"dash"}},{"type":"scatter","name":"mean_temp_train","mode":"lines","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0],"y":[-1.8746853167178659,-1.1677074134377627,-0.27424020186330245,0.5721634930931321,1.3051224320933414,1.2496087247869545,0.9210821689242298,0.8211757203220286,0.6160116384203276,0.06563801797885854,-0.8392854454415533,-1.6311701341335758,-1.7697077179983427,-1.335077067567901,-0.6224731732393086,0.15299347209451797,0.8825335427039144,1.2067700427035408,0.8869571357612991,0.6983550398934004]},{"type":"scatter","name":"humidity_data","mode":"markers","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[0.8950089305979064,0.8184103047433504,-0.20183686865692718,-1.8040933293829653,-2.202730212994396,-0.10762770079530037,1.0246068502230388,1.1569541354946669,0.29949282403523664,0.7001682134282649,0.41845563613457704,1.323980122095417,1.7060583058048504,0.9165990441519875,0.14288609682316306,-1.3793356733953719,-1.3031210452311734,-1.2376057394135584,0.1796056740310767,0.07926902459519647,0.21749940162014536,-0.08398378579252481,-0.3482493581632638,0.6785672111065525,1.2575933294242039,0.287139623154479,0.5427852423530937,-0.6082897032499905,-1.8948552226214292,-0.7705953609022242,0.6383789860775846,0.7321413932637466,-0.44553238337084616,-0.06859111551456204,0.459138693017879,0.7978772688964758,1.239563264720876,0.14719733837967122,-0.36904653372051155,-2.181237069647178,-1.4987058660408903,-0.5993249801179769,1.0637023440578648,0.8925177716576211,0.05066318582633409,-0.28605047830554076,-0.43831963898277326,0.6007366987949436,1.237331212246076,0.2870563774340041,-0.8627978014632336,-2.099454636427636],"xaxis":"x2","yaxis":"y2"},{"type":"scatter","name":"humidity_predict","mode":"lines","x":[20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[0.4407974417384145,0.335814018420799,0.5158460174284373,0.9931786560029403,1.1060975632685313,0.6218795476893627,-0.25798797564789194,-1.2387797068746957,-1.7382489951368236,-0.6120630145600937,0.393577748460331,0.4634403521624105,0.321400881278544,0.2961533033116729,0.617596130581661,0.9610535309326262,0.8006096017626734,0.13315669564872196,-0.7921572180546502,-1.5996421120082955,-1.2931774050911802,0.0371704633572415,0.44333343400499464,0.3416423374706693,0.2471075903481689,0.41562183943913394,0.8005026101792501,0.8456317266493134,0.3532323353512654,-0.49062470726486385,-1.3734248708167078,-1.576158796545749],"xaxis":"x2","yaxis":"y2","line":{"dash":"dash"}},{"type":"scatter","name":"humidity_train","mode":"lines","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0],"y":[0.8950089305979064,0.7108661688706004,-0.42504698027140525,-1.6080680880546758,-2.037294863541058,-0.27375744840966004,0.7387824936591638,0.7329283319935981,0.591888572660724,0.4902971294622061,0.6875435302423974,1.2999314020629875,1.490222237507779,1.004723156423658,0.07901898187616987,-1.0029551446821268,-1.811145867880187,-1.054549140643468,0.34199840410427806,0.5872969027362414],"xaxis":"x2","yaxis":"y2"},{"type":"scatter","name":"wind_speed_data","mode":"markers","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[-1.0622483675084964,0.2866089963180661,0.9421809893820605,0.5789924449321752,1.0373011430961487,1.3696272046593463,0.22765562861257518,0.2407596157966106,0.34757656753348704,-2.0829192830312144,-1.3594221675986469,-0.9845465695692052,-0.6909968521750836,-0.2609995874388895,0.1077303079621565,0.9990751310733674,0.8498546787208348,1.6339249536569462,0.31445253517161675,0.3843280410197091,0.5833634490117884,-1.4943248282947406,-1.9344747891951188,-1.4199564147282107,-0.8439028622346405,-0.30404132105812964,0.4026435934192968,0.8260697353712222,1.0996524999921853,0.9482591675967841,0.851973604631713,-0.7336819279607797,0.16141761224482387,-1.0131520693660658,-2.4500545885859024,-1.5928254536240538,-1.3425959992967833,-0.4917412468745312,0.14908249030672655,1.4173595423450718,1.3249209733111336,1.0927982978620754,-0.3607338004223368,0.1304289050754564,0.30394817226034127,0.19307941442785168,-0.4697054669186651,-0.3987000366911636,0.013304160751089191,0.3337158648364214,1.0071240196883449,1.1318138915052034],"xaxis":"x3","yaxis":"y3"},{"type":"scatter","name":"wind_speed_predict","mode":"lines","x":[20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[-0.4228687935091334,-0.9996557480787458,-1.31873531130892,-1.072071105863789,-0.5702695012987853,-0.08595159554654438,0.31812784635206537,0.6347377690601093,0.8991313933492054,0.9451827446268815,0.4738709888535102,-0.08248380170250207,-0.6324227801268121,-1.1257603214944256,-1.2020583730407213,-0.8281406935830292,-0.33756770618309173,0.1027622951347252,0.4595444803796398,0.7380213553564698,0.9393780797388633,0.6778808905119631,0.13626429270735502,-0.4073279697318359,-0.9312633964706645,-1.199545887197881,-0.9740900287706836,-0.5099672588270758,-0.05132892063443479,0.3327856013769102,0.6319531350232903,0.8709498822409896],"xaxis":"x3","yaxis":"y3","line":{"dash":"dash"}},{"type":"scatter","name":"wind_speed_train","mode":"lines","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0],"y":[-1.0622483675084964,0.14570652996633918,0.6363304646567752,0.9565475142803184,1.2719398172779446,1.2745631037834169,0.6966664863480119,0.12264955555984441,-0.45352964505024623,-1.1194222303856145,-1.4971195964154558,-1.197928307983989,-0.6416371329665119,-0.1273665175081518,0.29795771423888784,0.6338826524392149,0.9110033275159173,1.1004216636251638,0.7097716060545158,0.13693358648670925],"xaxis":"x3","yaxis":"y3"},{"type":"scatter","name":"meanpressure_data","mode":"markers","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[0.21925806231331432,0.16196180503671928,0.03505782026846573,-0.12888834765053261,-0.32075094983053937,-0.3965344479451143,-0.39739460598099435,-0.3052111804095199,-0.19948463347672396,-0.021736213055168815,0.14410077529269752,0.16784064342639346,0.2515617152233699,0.11678189690344691,0.08146423912839706,-0.06445524861193747,-0.20890417965998495,-0.4180165313979852,-0.37296060133114023,-0.30107744738510017,-0.1886096874010716,0.029034438568977094,0.10596792512967107,0.17365460674562827,0.2506534642371775,0.13115441091692204,0.10183914341729557,-0.09426092205806323,-0.24331937148697244,-0.33778152357730107,-0.35457143973791216,-0.2712191641216393,-0.15724378917166348,0.026552657211810764,0.12228751769042931,0.20789624742875867,0.19436851426886093,0.1652695224992091,6.525728778113121,-0.1455896670984204,-0.26279450845946706,-0.3772031571178986,-0.38510602798823973,-2.281426436921991,0.1711144550392202,-0.041197649219321036,-0.5573537359972486,0.1723558237466763,-0.6896062220111515,0.15076147595248865,-0.003032656175887003,-0.18093559328023856],"xaxis":"x4","yaxis":"y4"},{"type":"scatter","name":"meanpressure_predict","mode":"lines","x":[20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0],"y":[-0.17568835608974,-0.2166154698471055,-0.20617080399140617,-0.11715975597921402,-0.035660706286728815,-0.0073462667892219835,-0.026932269562164848,-0.10513314486121329,-0.3200999829262922,-0.47296756047778854,-0.29823119130267367,-0.1908697470751912,-0.2008855718262165,-0.22672690317327948,-0.1802678589620928,-0.08913276726560221,-0.03160267431544212,-0.025633190749212338,-0.06908898157371787,-0.20551600064031944,-0.446749914078238,-0.38853563755360926,-0.22982503436516696,-0.19525832774225874,-0.22410067611669898,-0.21008817477378816,-0.12830198004788063,-0.054684780455038766,-0.03040693375748028,-0.05497440636232242,-0.15024396906162527,-0.3771716617933828],"xaxis":"x4","yaxis":"y4","line":{"dash":"dash"}},{"type":"scatter","name":"meanpressure_train","mode":"lines","x":[0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0],"y":[0.21925806231331432,0.09602004286261275,0.030306935498949094,-0.07640026001255688,-0.3706474144648388,-0.49535287577305603,-0.24938273587836196,-0.1359544221285176,-0.15608752738734358,-0.20450063860009224,-0.19488533166584593,-0.0960391562043246,-0.006060927207692561,0.024922960306250363,0.008110458628185142,-0.05422809357077196,-0.23365767706778004,-0.48916326281258143,-0.3465004539854287,-0.19057609603297523],"xaxis":"x4","yaxis":"y4"}],"layout":{"grid":{"rows":4,"columns":1,"pattern":"independent"},"yaxis":{"range":[-2.0,2.0]},"yaxis2":{"range":[-2.0,2.0]},"yaxis3":{"range":[-2.0,2.0]},"yaxis4":{"range":[-0.75,0.5]}},"config":{}});
</script>
<p>This seems to work well, and is good at matching the data points a long way into the future. This has been a whirlwind description of both Neural ODEs and this particular analysis. For a more detailed explanation, please refer to the original blog post by Sebastian Callh. We've also skipped over many more boring parts of the code, and you can see the full code for this example in the <a href="https://github.com/martinjrobins/diffsol">Diffsol repository</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../primer/spring_mass_fitting.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../specify/specifying_the_problem.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../primer/spring_mass_fitting.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../specify/specifying_the_problem.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
